# Define backend servers for load balancing
upstream vllm_backends {
    # By default Nginx uses round-robin (evenly distributed requests)
    # You can enable least_conn for smarter balancing
    #least_conn;  # (optional) Use least connection method for load balancing
    # By default, Nginx uses round-robin (requests distributed evenly)
    server 192.168.1.1:8000 max_fails=3 fail_timeout=30s;  # Backend 1 with failure handling (by passive health checks)
    server 192.168.1.2:8000 max_fails=3 fail_timeout=30s;  # Backend 2 with failure handling (by passive health checks)
    server 192.168.1.3:8000 max_fails=3 fail_timeout=30s;  # Backend 3 with failure handling (by passive health checks)
    server 192.168.1.4:8000 max_fails=3 fail_timeout=30s;  # Backend 4 with failure handling (by passive health checks)
    server 192.168.1.5:8000 max_fails=3 fail_timeout=30s;  # Backend 5 with failure handling (by passive health checks)
    server 192.168.1.6:8000 max_fails=3 fail_timeout=30s;  # Backend 6 with failure handling (by passive health checks)
    server 192.168.1.7:8000 max_fails=3 fail_timeout=30s;  # Backend 7 with failure handling (by passive health checks)
    server 192.168.1.8:8000 max_fails=3 fail_timeout=30s;  # Backend 8 with failure handling (by passive health checks)

    # This is passive health checking (max_fails=3 fail_timeout=30s;). Nginx marks a server as down if it fails to respond correctly.
    # max_fails=3 → After 3 consecutive failed requests (connection error, timeout, 502/503), Nginx stops sending requests to this server.
    # fail_timeout=30s → Backend is marked “unavailable” for 30 seconds.
    # Works without sending extra probes, just based on normal traffic
    # For active health checks, consider using the Nginx Plus commercial version.

    #keepalive 32;  # Optional. Keeps 32 idle connections open to the backend servers to reduce connection setup overhead for high-traffic APIs.

}
